Day1: 
Leetcode 217. Contains Duplicate
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
Example 1:
Input: nums = [1,2,3,1]
Output: true
Example 2:
Input: nums = [1,2,3,4]
Output: false
----------------------------------------
// Time complexity: O(n)
// Space complexity: O(n)
var containsDuplicate = function(nums) {
    const s = new Set(nums); 
    return s.size !== nums.length
}
----------------------------------------
var containsDuplicate = function(nums) {
    nums.sort((a,b) => a-b);
    for(let i = 0; i <= nums.length-1; i++){
        if(nums[i] === nums[i+1]){
            return true
        }
    }
    return false
};
----------------------------------------
var containsDuplicate = function(nums) {
    const s = new Set(nums);
    if(s.size !== nums.length)
        return true
    return false;
   
};
----------------------------------------
var containsDuplicate = function (nums) {
  return [...new Set(nums)].length !== nums.length;
};
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Day 2:
Generate Fibonacci series:

function generateFibonacci(n) {
  const fibonacciSeries = [0, 1];
  for (let i = 2; i < n; i++) {
    const nextFibonacci = fibonacciSeries[i - 2] + fibonacciSeries[i - 1];
    fibonacciSeries.push(nextFibonacci);
  }
  return fibonacciSeries;
}
const fibonacciOutput = generateFibonacci(6);
console.log(fibonacciOutput);
-------------------------------------------------------------------------------------------------------------------------------------------------------
Day 3: Two Sum
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

var twoSum = function(nums, target) {
    for(i=0;i<nums.length;i++){
        for(j=i+1;j<nums.length;j++){
            if(nums[i]+nums[j]===target){
                let output = [i,j];
                return output;
            }
        }
    }
};
----------------------------------------
function twoSum(arr, target) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    if (target - arr[i] in obj) {
      return [obj[target-arr[i]], i];
    } else {
      obj[arr[i]] = i;
    }
  }
  return [];
};
----------------------------------------
function twoSum(nums, target) {
  let vals = {};

  for (let i = 0; i < nums.length; i++) {
    if (target - nums[i] in vals) {
      return [vals[target-nums[i]], i];
    } else {
      vals[nums[i]] = i;
    }
  }
  return [];
};
----------------------------------------
var twoSum = function(nums, target) {
       const map = {};
    for(let i = 0; i < nums.length; i++){
        const diff = target - nums[i];
        if(map.hasOwnProperty(diff)){
           return [map[diff], i];
			break;
        }
        map[nums[i]] = i;
    }
    
    return result;
};
------------------------------------------------------------------------------------------------------------------------------------------------
Day 4:
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
Example 1:
Input: nums = [3,2,3]
Output: 3

var majorityElement = function(nums) {
    let map = {}
    for(let item of nums){
        if(!map[item]) {
            map[item] = 1;
        } else {
            map[item]++;
        }
        if (map[item] >= nums.length/2) return item
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------
Day 5: Find Words Containing Character
Input: words = ["leet","code"], x = "e"
Output: [0,1]
Explanation: "e" occurs in both words: "leet", and "code". Hence, we return indices 0 and 1.

/*var findWordsContaining = function(words, x) {
    return words.reduce((acc, curr, i) => 
                            curr.includes(x)
                            ? [...acc, i]
                            : acc, 
                        [])
};

var findWordsContaining = function(words, x) {
    return words.reduce((acc, curr, i) => 
                            curr.indexOf(x) > -1 
                            ? [...acc, i]
                            : acc, 
                        [])
};

const findWordsContaining = (words, x) => {
  const res = [];
  words.forEach((word, index) => {
    if (word.includes(x)) res.push(index);
  });
  return res;
};

function findWordsContaining(words, x) {
    let indices = [];
    for (let i = 0; i < words.length; i++) {
        if (words[i].includes(x)) {
            indices.push(i);
        }
    }
    return indices;
} */

var findWordsContaining = function(words, x) {
    let out = []
    words.map((word , index)=>{
        if(word.includes(x)){
            out.push(index)
        }
    })
    return out
};
----------------------------------------------------------------------------------------------------------------------------------------------------
Day 6: Running Sum of 1d Array

Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

/*var runningSum = function(nums) {
    let result=[]; let sum=0;
    for(let i=0; i<nums.length; i++){
      sum=sum+nums[i]
      result.push(sum);
    }
    return result;  
}*/

const runningSum = nums => {
  let sum = 0;
  return nums.map(num => sum += num);
};
----------------------------------------------------------------------------------------------------------------------------------------------------
Day 7: Number of Good Pairs

Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.

/*var numIdenticalPairs = function(nums) {
  let pair=0
  for(let i=0;i<nums.length;i++){
    for(let j=i+1; j<nums.length;j++){
       if(nums[i] === nums[j]){
         pair++;
       }
    }
  }  
  return pair;
};*/

var numIdenticalPairs = function(nums) {
    let count = {};
    let result = 0;

    for (let num of nums) {
        if (num in count) {
            result += count[num];
            count[num]++;
        } else {
            count[num] = 1;
        }
    }

    return result;
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 8: Check If Two String Arrays are Equivalent

Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.

/*var arrayStringsAreEqual = function(word1, word2) {
        let left = ""; // Initialize left and right to empty strings
        let right = "";

        // Concatenate strings in word1
        for (let i = 0; i < word1.length; i++) {
            left += word1[i];
        }

        // Concatenate strings in word2
        for (let i = 0; i < word2.length; i++) {
            right += word2[i];
        }

        // Use equals() method to compare strings
        return left === right;

};*/

function arrayStringsAreEqual(word1, word2) {
    let s1 = word1.join('');
    let s2 = word2.join('');

    return s1 === s2;
}
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 9: How Many Numbers Are Smaller Than the Current Number 

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).


/*var smallerNumbersThanCurrent = function (nums) {
  let res = [];

  for (const i of nums) {
    const c = nums.reduce((count, num) => {
      if (num < i) count++;
      return count;
    }, 0);
    res.push(c);
  }

  return res;
};

var smallerNumbersThanCurrent = function(nums) {
    const num=[...nums]
    num.sort((a,b)=>a-b)
    for(let i=0;i<nums.length;i++){
        nums[i]=num.indexOf(nums[i])
    }
    return nums
}; */

var smallerNumbersThanCurrent = function(nums) {
    let ar = []
   
    for(let i = 0 ; i<nums.length; i++){
         let count = 0
        for(let j=0 ; j<nums.length; j++){
            if(nums[j] < nums[i]){
                count++;    
            } 
        }
        ar.push(count)
    }
    return ar
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 9: Sort Array by Increasing Frequency
Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.

/*var frequencySort = function(nums) {
    const counts = [];
    for(let i = 0; i < nums.length; i++) {
        counts[nums[i]] = counts[nums[i]] ? counts[nums[i]] + 1 : 1;
    }
    return nums.sort((a, b) => {
        if (counts[a] > counts[b]) {
            return 1;
        } else if (counts[a] < counts[b]) {
            return -1;
        }
        return b - a;
    });
};*/

var frequencySort = function(nums) {
    const obj={}
    for (let num of nums){
        if(!obj[num]){
            obj[num]=1
        }else{
            obj[num]++
        }
    }

  return nums.sort((a,b)=>{
      const countOfA=obj[a]
      const countOfB=obj[b]
      if(countOfA!=countOfB) return countOfA-countOfB
      else return b-a
  })
    
};
-----------------------------------------------------------------------------------------------------------------------------------------------------
Day 10: Valid Parentheses

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Input: s = "()"
Output: true

var isValid = function(s) {
    if (s.length <=1) return false
    
    let stack = []
    let hash = {
        '(' : ')',
        '[' : ']',
        '{' : '}'
    }
    
    for(let i = 0; i < s.length; i++){
        if (hash[s[i]]) stack.push(hash[s[i]])
        else if (s[i] !== stack.pop()) return false
    }
    return !stack.length
};
console.log(isValid("{}[]"))
/*var isValid = function(s) {
    if (s.length === 0) {
        return true;
    }
    
    const stack = [];
    const bracketMap = {
        ")": '(',
        "]": '[',
        "}": '{',
    };
    
    for(let i = 0; i < s.length; i++) {
        if (s[i] === '(' || s[i] === '[' || s[i] === '{') {
		    // add open brackets in the stack
            stack.push(s[i]);
        } else {
		    // remove the latest item in stack if it matches the current closing bracket
            if (stack[stack.length - 1] === bracketMap[s[i]]) {
                stack.pop();
            } else {
                return false;
            }
            
        } 
    }
    // string is valid if all matching brackets are removed from the stack
    return stack.length === 0;
};*/
-----------------------------------------------------------------------------------------------------------------------------------------------------
Day 11: Fizz Buzz
Example 1:

Input: n = 3
Output: ["1","2","Fizz"]
Example 2:

Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]

/*var fizzBuzz = function(n) {
    var ans = [];

    for (var i = 1; i <= n; i++) {
        if (i % 3 === 0 && i % 5 === 0) {
            ans.push("FizzBuzz");
        } else if (i % 3 === 0) {
            ans.push("Fizz");
        } else if (i % 5 === 0) {
            ans.push("Buzz");
        } else {
            ans.push(i.toString());
        }
    }

    return ans;    
};*/
var fizzBuzz = function(n) {
    let arr = [];
    let i = 1;
    
    while (i <= n){
        if (i % 3 == 0 & i % 5 == 0) arr.push("FizzBuzz");
        else if (i % 3 == 0) arr.push("Fizz");
        else if (i % 5 == 0) arr.push("Buzz");
        else arr.push(i.toString());
        i++;
    }
    return arr;
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 12: Truncate Sentence
Input: s = "Hello how are you Contestant", k = 4
Output: "Hello how are you"
Explanation:
The words in s are ["Hello", "how" "are", "you", "Contestant"].
The first 4 words are ["Hello", "how", "are", "you"].
Hence, you should return "Hello how are you".

var truncateSentence = function(s, k) {
      return s.split(' ').slice(0,k).join(' ')
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 13: Check if All A's Appears Before All B's.

Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, 
return false.
Example 1:
Input: s = "aaabbb"
Output: true
Explanation:
The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true.


/*var checkString = function(s) {
    let ss=s.split('').sort().join('')
    return ss==s   
};

var checkString = function(s) {
    for(let i=0;i<s.length;i++){
        if(s[i]=='b' && s[i+1]=='a'){
            return false;
        }
    }
    return true
}; 

var checkString = function (s) {
    return s.indexOf("ba") === -1;    // is no  a  after  b ?
};*/

const checkString = (s) => {
    let flag = false;

    for (const ch of s) {
        if (ch === 'b') {
            flag = true;
        }

        if (flag && ch === 'a') {
            return false;
        }
    }

    return true;
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 14: 

/*var isAcronym = function(words, s) {
    var res="";
    for(let i=0; i<words.length;i++){
      res= res+words[i][0];
    }
    if(res==s){
        return true;
    }
    return false;
};
var isAcronym = function (words, s) {
  if (words.length !== s.length ) return false;

  for (let i = 0; i < words.length; i++) {
    if (words[i][0] !== s[i]) return false;
  }
  
  return true;
};
const isAcronym = (words, s) => s === words.map( w => w[0]).join('')*/
var isAcronym = function(words, s) {
    return words.length === s.length && words.every((v, i) => v[0] === s[i]);
};

------------------------------------------------------------------------------------------------------------------------------------------------------
Day 15: Check if a String Is an Acronym of Words

Input: words = ["alice","bob","charlie"], s = "abc"
Output: true
Explanation: The first character in the words "alice", "bob", and "charlie" are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the acronym. 
/*var isAcronym = function(words, s) {
    var res="";
    for(let i=0; i<words.length;i++){
      res= res+words[i][0];
    }
    if(res==s){
        return true;
    }
    return false;
};
var isAcronym = function (words, s) {
  if (words.length !== s.length ) return false;

  for (let i = 0; i < words.length; i++) {
    if (words[i][0] !== s[i]) return false;
  }
  
  return true;
};
const isAcronym = (words, s) => s === words.map( w => w[0]).join('')*/
var isAcronym = function(words, s) {
    return words.length === s.length && words.every((v, i) => v[0] === s[i]);
};



------------------------------------------------------------------------------------------------------------------------------------------------------
Day 16:  Isomorphic Strings
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

 

Example 1:

Input: s = "egg", t = "add"
Output: true
Example 2:

Input: s = "foo", t = "bar"
Output: false

/*var isIsomorphic = function(s, t) {
    
    for (let i=0; i<s.length; i++) {

        if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
            
            return false;
        }
    }
    return true;
};

var isIsomorphic = function (s, t) {
  if (s.length != t.length) return false;
  let sArr = [];
  let tArr = [];
  for (let i = 0; i < s.length; i++) {
    sArr.push(s.indexOf(s[i]));
    tArr.push(t.indexOf(t[i]));
    if (sArr[i] != tArr[i]) return false;
  }
  return true;
};*/

var isIsomorphic = function(s, t) {
    let arr1 = {}
    let arr2 = {}
    for (let i=0;i<s.length;i++) {
        if(arr1[s[i]] !== arr2[t[i]]) {
            return false
        }else{
            arr1[s[i]] = i,
            arr2[t[i]] = i
        }
    }
    return true
};
======================================================================================================================================================
Day 17: Longest Common Prefix

Input: strs = ["flower","flow","flight"]
Output: "fl"

/*var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  let r = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) return r;
    }
    r += strs[0][i];
  }
  return r;
};*/

var longestCommonPrefix = function (strs) {
    let output = "";
    for (let i = 0; i < strs[0].length; i++) {
        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];
        else break;
    }
    return output;
};
======================================================================================================================================================
Day 18: Reverse String:
Write a function that reverses a string. The input string is given as an array of characters s.
You must do this by modifying the input array in-place with O(1) extra memory.

Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]

/*const reverseString=(arr)=>{
  for(let i=0; i<arr.length/2; i++){
    [arr[i], arr[arr.length-i-1]]=[arr[arr.length-i-1], arr[i]]
  }
  return arr
}*/

var reverseString = function(s) {
    var i = 0;
    var j = s.length - 1;
    while (i < j) {
        [s[i], s[j]] = [s[j], s[i]];
        i++;
        j--;
    }
};

var reverseString = function(s) {
    return s.reverse()
    
};

======================================================================================================================================================
Day 19: Check If String Is a Prefix of Array

Input: s = "iloveleetcode", words = ["i","love","leetcode","apples"]
Output: true
Explanation:
s can be made by concatenating "i", "love", and "leetcode" together.

var isPrefixString = function(s, words) {
    let compareStr = '';

    for (let i = 0; i < words.length; i++) {
        compareStr = compareStr + words[i];
        if (compareStr === s) {
            return true;
        }
    }

    return false;
};
======================================================================================================================================================
Day 20: Valid Anagram

Input: s = "anagram", t = "nagaram"
Output: true

var isAnagram = function(s, t) {
    if (s.length !== t.length) return false;
    return s.split("").sort().join("") === t.split("").sort().join("");
};

======================================================================================================================================================
Day 21 : Check If a Word Occurs As a Prefix of Any Word in a Sentence

Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4
Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.

/*var isPrefixOfWord = function (sentence, searchWord) {
    let words = sentence.split(' ')

    for (let i = 0; i < words.length; i++) {
        if (words[i].startsWith(searchWord)) return i + 1
    }

    return -1
};*/

function isPrefixOfWord(sentence, searchWord){
  return sentence.split(' ').findIndex(e => e.startsWith(searchWord)) + 1 || -1;
}
======================================================================================================================================================
Day 22: Jewels and Stones

Example 1:

Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
Example 2:

Input: jewels = "z", stones = "ZZ"
Output: 0

/*var numJewelsInStones = function(jewels, stones) {
    let count = 0;

    for(let i=0; i<jewels.length;i++){
        for(let j=0; j<stones.length; j++){
            if(jewels[i]===stones[j]){
               count++;
            }
        }
    }
    return count;
    
};
var numJewelsInStones = function(J, S) {

	// declare a count & length variable 

    let count = 0
    let len = S.length
	
	// Iterate through the longest array S. Increment count by 1 if it exists in J
	
    for (let i = 0; i < len; i++){
        if (J.indexOf(S[i]) >= 0){
            count++
        }
    }
    return count
};

var numJewelsInStones = function(jewels, stones) {
   let count = 0;
   for(let val of stones){
       if(jewels.includes(val)){
           count++;
        }
    }
    return count;
};*/

var numJewelsInStones = function(jewels, stones) {
    return [...stones].reduce((a,e)=>a+jewels.includes(e),0)
};

======================================================================================================================================================
Day 23: Number of Days Between Two Dates

Input: date1 = "2019-06-29", date2 = "2019-06-30"
Output: 1

/*const daysBetweenDates = (date1, date2) => {
    const millisecondsInADay = 1000*60*60*24;    
    return Math.abs((new Date(date1).getTime() - new Date(date2).getTime()) / millisecondsInADay);
}*/
const daysBetweenDates = (D1, D2, DF = Math.abs((new Date(D1) - new Date(D2)))) => DF / (1000 * 60 * 60 * 24)

======================================================================================================================================================
Day 24:  Count Elements With Maximum Frequency

Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.

var maxFrequencyElements = function (nums) {
    const obj = {}
    nums.forEach((n) => obj[n] ? obj[n]++ : obj[n] = 1)

    const max = Math.max(...Object.values(obj))
    return Object.values(obj).reduce((acc, cur) => {
        if (cur == max) {
            acc += cur
        } return acc
    }, 0)
};

======================================================================================================================================================
Day 25: Is Object Empty
Example 1:

Input: obj = {"x": 5, "y": 42}
Output: false
Explanation: The object has 2 key-value pairs so it is not empty.
Example 2:

Input: obj = {}
Output: true
Explanation: The object doesn't have any key-value pairs so it is empty.


/*var isEmpty = function(obj) {
    for (let key in obj)
        return false;
    return true;
};

If array/object is not empty, interpreter will enter the for-in loop and hence first return statement (false) will be executed.
If array/object is empty, interpreter won't enter for-in loop and hence second return statement (true) will be executed.
*/

var isEmpty = function(obj) {
  if (Array.isArray(obj)) {
    return obj.length === 0;
  } else if (typeof obj === 'object') {
    return Object.keys(obj).length === 0;
  }
  return false; 
};

======================================================================================================================================================
Day 26: Longest Valid Parentheses

Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".

function longestValidParentheses(s) {
    let stack = [-1]; // Initialize stack with -1 to handle edge case where the first character is ')'
    let maxLength = 0;

    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i); // Push the index of an open parenthesis onto the stack
        } else {
            stack.pop(); // Pop the top element from the stack

            if (stack.length === 0) {
                stack.push(i); // If stack becomes empty, push the current index onto the stack
            } else {
                // Calculate the length of the valid substring and update maxLength
                maxLength = Math.max(maxLength, i - stack[stack.length - 1]);
            }
        }
    }

    return maxLength; // Return the length of the longest valid parenthesis substring
}

======================================================================================================================================================
Day 2

======================================================================================================================================================
Day 2

======================================================================================================================================================
Day 2
