Day1: 
Leetcode 217. Contains Duplicate
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
Example 1:
Input: nums = [1,2,3,1]
Output: true
Example 2:
Input: nums = [1,2,3,4]
Output: false
----------------------------------------
// Time complexity: O(n)
// Space complexity: O(n)
var containsDuplicate = function(nums) {
    const s = new Set(nums); 
    return s.size !== nums.length
}
----------------------------------------
var containsDuplicate = function(nums) {
    nums.sort((a,b) => a-b);
    for(let i = 0; i <= nums.length-1; i++){
        if(nums[i] === nums[i+1]){
            return true
        }
    }
    return false
};
----------------------------------------
var containsDuplicate = function(nums) {
    const s = new Set(nums);
    if(s.size !== nums.length)
        return true
    return false;
   
};
----------------------------------------
var containsDuplicate = function (nums) {
  return [...new Set(nums)].length !== nums.length;
};
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Day 2:
Generate Fibonacci series:

function generateFibonacci(n) {
  const fibonacciSeries = [0, 1];
  for (let i = 2; i < n; i++) {
    const nextFibonacci = fibonacciSeries[i - 2] + fibonacciSeries[i - 1];
    fibonacciSeries.push(nextFibonacci);
  }
  return fibonacciSeries;
}
const fibonacciOutput = generateFibonacci(6);
console.log(fibonacciOutput);
-------------------------------------------------------------------------------------------------------------------------------------------------------
Day 3: Two Sum
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

var twoSum = function(nums, target) {
    for(i=0;i<nums.length;i++){
        for(j=i+1;j<nums.length;j++){
            if(nums[i]+nums[j]===target){
                let output = [i,j];
                return output;
            }
        }
    }
};
----------------------------------------
function twoSum(arr, target) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    if (target - arr[i] in obj) {
      return [obj[target-arr[i]], i];
    } else {
      obj[arr[i]] = i;
    }
  }
  return [];
};
----------------------------------------
function twoSum(nums, target) {
  let vals = {};

  for (let i = 0; i < nums.length; i++) {
    if (target - nums[i] in vals) {
      return [vals[target-nums[i]], i];
    } else {
      vals[nums[i]] = i;
    }
  }
  return [];
};
----------------------------------------
var twoSum = function(nums, target) {
       const map = {};
    for(let i = 0; i < nums.length; i++){
        const diff = target - nums[i];
        if(map.hasOwnProperty(diff)){
           return [map[diff], i];
			break;
        }
        map[nums[i]] = i;
    }
    
    return result;
};
------------------------------------------------------------------------------------------------------------------------------------------------
Day 4:
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
Example 1:
Input: nums = [3,2,3]
Output: 3

var majorityElement = function(nums) {
    let map = {}
    for(let item of nums){
        if(!map[item]) {
            map[item] = 1;
        } else {
            map[item]++;
        }
        if (map[item] >= nums.length/2) return item
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------
Day 5: Find Words Containing Character
Input: words = ["leet","code"], x = "e"
Output: [0,1]
Explanation: "e" occurs in both words: "leet", and "code". Hence, we return indices 0 and 1.

/*var findWordsContaining = function(words, x) {
    return words.reduce((acc, curr, i) => 
                            curr.includes(x)
                            ? [...acc, i]
                            : acc, 
                        [])
};

var findWordsContaining = function(words, x) {
    return words.reduce((acc, curr, i) => 
                            curr.indexOf(x) > -1 
                            ? [...acc, i]
                            : acc, 
                        [])
};

const findWordsContaining = (words, x) => {
  const res = [];
  words.forEach((word, index) => {
    if (word.includes(x)) res.push(index);
  });
  return res;
};

function findWordsContaining(words, x) {
    let indices = [];
    for (let i = 0; i < words.length; i++) {
        if (words[i].includes(x)) {
            indices.push(i);
        }
    }
    return indices;
} */

var findWordsContaining = function(words, x) {
    let out = []
    words.map((word , index)=>{
        if(word.includes(x)){
            out.push(index)
        }
    })
    return out
};
----------------------------------------------------------------------------------------------------------------------------------------------------
Day 6: Running Sum of 1d Array

Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

/*var runningSum = function(nums) {
    let result=[]; let sum=0;
    for(let i=0; i<nums.length; i++){
      sum=sum+nums[i]
      result.push(sum);
    }
    return result;  
}*/

const runningSum = nums => {
  let sum = 0;
  return nums.map(num => sum += num);
};
----------------------------------------------------------------------------------------------------------------------------------------------------
Day 7: Number of Good Pairs

Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.

/*var numIdenticalPairs = function(nums) {
  let pair=0
  for(let i=0;i<nums.length;i++){
    for(let j=i+1; j<nums.length;j++){
       if(nums[i] === nums[j]){
         pair++;
       }
    }
  }  
  return pair;
};*/

var numIdenticalPairs = function(nums) {
    let count = {};
    let result = 0;

    for (let num of nums) {
        if (num in count) {
            result += count[num];
            count[num]++;
        } else {
            count[num] = 1;
        }
    }

    return result;
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 8: Check If Two String Arrays are Equivalent

Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.

/*var arrayStringsAreEqual = function(word1, word2) {
        let left = ""; // Initialize left and right to empty strings
        let right = "";

        // Concatenate strings in word1
        for (let i = 0; i < word1.length; i++) {
            left += word1[i];
        }

        // Concatenate strings in word2
        for (let i = 0; i < word2.length; i++) {
            right += word2[i];
        }

        // Use equals() method to compare strings
        return left === right;

};*/

function arrayStringsAreEqual(word1, word2) {
    let s1 = word1.join('');
    let s2 = word2.join('');

    return s1 === s2;
}
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 9: How Many Numbers Are Smaller Than the Current Number 

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).


/*var smallerNumbersThanCurrent = function (nums) {
  let res = [];

  for (const i of nums) {
    const c = nums.reduce((count, num) => {
      if (num < i) count++;
      return count;
    }, 0);
    res.push(c);
  }

  return res;
};

var smallerNumbersThanCurrent = function(nums) {
    const num=[...nums]
    num.sort((a,b)=>a-b)
    for(let i=0;i<nums.length;i++){
        nums[i]=num.indexOf(nums[i])
    }
    return nums
}; */

var smallerNumbersThanCurrent = function(nums) {
    let ar = []
   
    for(let i = 0 ; i<nums.length; i++){
         let count = 0
        for(let j=0 ; j<nums.length; j++){
            if(nums[j] < nums[i]){
                count++;    
            } 
        }
        ar.push(count)
    }
    return ar
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 9: Sort Array by Increasing Frequency
Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.

/*var frequencySort = function(nums) {
    const counts = [];
    for(let i = 0; i < nums.length; i++) {
        counts[nums[i]] = counts[nums[i]] ? counts[nums[i]] + 1 : 1;
    }
    return nums.sort((a, b) => {
        if (counts[a] > counts[b]) {
            return 1;
        } else if (counts[a] < counts[b]) {
            return -1;
        }
        return b - a;
    });
};*/

var frequencySort = function(nums) {
    const obj={}
    for (let num of nums){
        if(!obj[num]){
            obj[num]=1
        }else{
            obj[num]++
        }
    }

  return nums.sort((a,b)=>{
      const countOfA=obj[a]
      const countOfB=obj[b]
      if(countOfA!=countOfB) return countOfA-countOfB
      else return b-a
  })
    
};
-----------------------------------------------------------------------------------------------------------------------------------------------------
Day 10: Valid Parentheses

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Input: s = "()"
Output: true

var isValid = function(s) {
    if (s.length <=1) return false
    
    let stack = []
    let hash = {
        '(' : ')',
        '[' : ']',
        '{' : '}'
    }
    
    for(let i = 0; i < s.length; i++){
        if (hash[s[i]]) stack.push(hash[s[i]])
        else if (s[i] !== stack.pop()) return false
    }
    return !stack.length
};
console.log(isValid("{}[]"))
/*var isValid = function(s) {
    if (s.length === 0) {
        return true;
    }
    
    const stack = [];
    const bracketMap = {
        ")": '(',
        "]": '[',
        "}": '{',
    };
    
    for(let i = 0; i < s.length; i++) {
        if (s[i] === '(' || s[i] === '[' || s[i] === '{') {
		    // add open brackets in the stack
            stack.push(s[i]);
        } else {
		    // remove the latest item in stack if it matches the current closing bracket
            if (stack[stack.length - 1] === bracketMap[s[i]]) {
                stack.pop();
            } else {
                return false;
            }
            
        } 
    }
    // string is valid if all matching brackets are removed from the stack
    return stack.length === 0;
};*/
-----------------------------------------------------------------------------------------------------------------------------------------------------
Day 11: Fizz Buzz
Example 1:

Input: n = 3
Output: ["1","2","Fizz"]
Example 2:

Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]

/*var fizzBuzz = function(n) {
    var ans = [];

    for (var i = 1; i <= n; i++) {
        if (i % 3 === 0 && i % 5 === 0) {
            ans.push("FizzBuzz");
        } else if (i % 3 === 0) {
            ans.push("Fizz");
        } else if (i % 5 === 0) {
            ans.push("Buzz");
        } else {
            ans.push(i.toString());
        }
    }

    return ans;    
};*/
var fizzBuzz = function(n) {
    let arr = [];
    let i = 1;
    
    while (i <= n){
        if (i % 3 == 0 & i % 5 == 0) arr.push("FizzBuzz");
        else if (i % 3 == 0) arr.push("Fizz");
        else if (i % 5 == 0) arr.push("Buzz");
        else arr.push(i.toString());
        i++;
    }
    return arr;
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 12: Truncate Sentence
Input: s = "Hello how are you Contestant", k = 4
Output: "Hello how are you"
Explanation:
The words in s are ["Hello", "how" "are", "you", "Contestant"].
The first 4 words are ["Hello", "how", "are", "you"].
Hence, you should return "Hello how are you".

var truncateSentence = function(s, k) {
      return s.split(' ').slice(0,k).join(' ')
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 13: Check if All A's Appears Before All B's.

Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, 
return false.
Example 1:
Input: s = "aaabbb"
Output: true
Explanation:
The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true.


/*var checkString = function(s) {
    let ss=s.split('').sort().join('')
    return ss==s   
};

var checkString = function(s) {
    for(let i=0;i<s.length;i++){
        if(s[i]=='b' && s[i+1]=='a'){
            return false;
        }
    }
    return true
}; 

var checkString = function (s) {
    return s.indexOf("ba") === -1;    // is no  a  after  b ?
};*/

const checkString = (s) => {
    let flag = false;

    for (const ch of s) {
        if (ch === 'b') {
            flag = true;
        }

        if (flag && ch === 'a') {
            return false;
        }
    }

    return true;
};
------------------------------------------------------------------------------------------------------------------------------------------------------
Day 14: 

/*var isAcronym = function(words, s) {
    var res="";
    for(let i=0; i<words.length;i++){
      res= res+words[i][0];
    }
    if(res==s){
        return true;
    }
    return false;
};
var isAcronym = function (words, s) {
  if (words.length !== s.length ) return false;

  for (let i = 0; i < words.length; i++) {
    if (words[i][0] !== s[i]) return false;
  }
  
  return true;
};
const isAcronym = (words, s) => s === words.map( w => w[0]).join('')*/
var isAcronym = function(words, s) {
    return words.length === s.length && words.every((v, i) => v[0] === s[i]);
};

------------------------------------------------------------------------------------------------------------------------------------------------------
Day 15: Check if a String Is an Acronym of Words

Input: words = ["alice","bob","charlie"], s = "abc"
Output: true
Explanation: The first character in the words "alice", "bob", and "charlie" are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the acronym. 
/*var isAcronym = function(words, s) {
    var res="";
    for(let i=0; i<words.length;i++){
      res= res+words[i][0];
    }
    if(res==s){
        return true;
    }
    return false;
};
var isAcronym = function (words, s) {
  if (words.length !== s.length ) return false;

  for (let i = 0; i < words.length; i++) {
    if (words[i][0] !== s[i]) return false;
  }
  
  return true;
};
const isAcronym = (words, s) => s === words.map( w => w[0]).join('')*/
var isAcronym = function(words, s) {
    return words.length === s.length && words.every((v, i) => v[0] === s[i]);
};



------------------------------------------------------------------------------------------------------------------------------------------------------
Day 16:  Isomorphic Strings
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

 

Example 1:

Input: s = "egg", t = "add"
Output: true
Example 2:

Input: s = "foo", t = "bar"
Output: false

/*var isIsomorphic = function(s, t) {
    
    for (let i=0; i<s.length; i++) {

        if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
            
            return false;
        }
    }
    return true;
};

var isIsomorphic = function (s, t) {
  if (s.length != t.length) return false;
  let sArr = [];
  let tArr = [];
  for (let i = 0; i < s.length; i++) {
    sArr.push(s.indexOf(s[i]));
    tArr.push(t.indexOf(t[i]));
    if (sArr[i] != tArr[i]) return false;
  }
  return true;
};*/

var isIsomorphic = function(s, t) {
    let arr1 = {}
    let arr2 = {}
    for (let i=0;i<s.length;i++) {
        if(arr1[s[i]] !== arr2[t[i]]) {
            return false
        }else{
            arr1[s[i]] = i,
            arr2[t[i]] = i
        }
    }
    return true
};
======================================================================================================================================================
Day 17: Longest Common Prefix

Input: strs = ["flower","flow","flight"]
Output: "fl"

/*var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  let r = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) return r;
    }
    r += strs[0][i];
  }
  return r;
};*/

var longestCommonPrefix = function (strs) {
    let output = "";
    for (let i = 0; i < strs[0].length; i++) {
        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];
        else break;
    }
    return output;
};
======================================================================================================================================================
Day 18: Reverse String:
Write a function that reverses a string. The input string is given as an array of characters s.
You must do this by modifying the input array in-place with O(1) extra memory.

Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]

/*const reverseString=(arr)=>{
  for(let i=0; i<arr.length/2; i++){
    [arr[i], arr[arr.length-i-1]]=[arr[arr.length-i-1], arr[i]]
  }
  return arr
}*/

var reverseString = function(s) {
    var i = 0;
    var j = s.length - 1;
    while (i < j) {
        [s[i], s[j]] = [s[j], s[i]];
        i++;
        j--;
    }
};

var reverseString = function(s) {
    return s.reverse()
    
};

======================================================================================================================================================
Day 19: Check If String Is a Prefix of Array

Input: s = "iloveleetcode", words = ["i","love","leetcode","apples"]
Output: true
Explanation:
s can be made by concatenating "i", "love", and "leetcode" together.

var isPrefixString = function(s, words) {
    let compareStr = '';

    for (let i = 0; i < words.length; i++) {
        compareStr = compareStr + words[i];
        if (compareStr === s) {
            return true;
        }
    }

    return false;
};
======================================================================================================================================================
Day 20: Valid Anagram

Input: s = "anagram", t = "nagaram"
Output: true

var isAnagram = function(s, t) {
    if (s.length !== t.length) return false;
    return s.split("").sort().join("") === t.split("").sort().join("");
};

======================================================================================================================================================
Day 21 : Check If a Word Occurs As a Prefix of Any Word in a Sentence

Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4
Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.

/*var isPrefixOfWord = function (sentence, searchWord) {
    let words = sentence.split(' ')

    for (let i = 0; i < words.length; i++) {
        if (words[i].startsWith(searchWord)) return i + 1
    }

    return -1
};*/

function isPrefixOfWord(sentence, searchWord){
  return sentence.split(' ').findIndex(e => e.startsWith(searchWord)) + 1 || -1;
}
======================================================================================================================================================
Day 22: Jewels and Stones

Example 1:

Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
Example 2:

Input: jewels = "z", stones = "ZZ"
Output: 0

/*var numJewelsInStones = function(jewels, stones) {
    let count = 0;

    for(let i=0; i<jewels.length;i++){
        for(let j=0; j<stones.length; j++){
            if(jewels[i]===stones[j]){
               count++;
            }
        }
    }
    return count;
    
};
var numJewelsInStones = function(J, S) {

	// declare a count & length variable 

    let count = 0
    let len = S.length
	
	// Iterate through the longest array S. Increment count by 1 if it exists in J
	
    for (let i = 0; i < len; i++){
        if (J.indexOf(S[i]) >= 0){
            count++
        }
    }
    return count
};

var numJewelsInStones = function(jewels, stones) {
   let count = 0;
   for(let val of stones){
       if(jewels.includes(val)){
           count++;
        }
    }
    return count;
};*/

var numJewelsInStones = function(jewels, stones) {
    return [...stones].reduce((a,e)=>a+jewels.includes(e),0)
};

======================================================================================================================================================
Day 23: Number of Days Between Two Dates

Input: date1 = "2019-06-29", date2 = "2019-06-30"
Output: 1

/*const daysBetweenDates = (date1, date2) => {
    const millisecondsInADay = 1000*60*60*24;    
    return Math.abs((new Date(date1).getTime() - new Date(date2).getTime()) / millisecondsInADay);
}*/
const daysBetweenDates = (D1, D2, DF = Math.abs((new Date(D1) - new Date(D2)))) => DF / (1000 * 60 * 60 * 24)

======================================================================================================================================================
Day 24:  Count Elements With Maximum Frequency

Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.

var maxFrequencyElements = function (nums) {
    const obj = {}
    nums.forEach((n) => obj[n] ? obj[n]++ : obj[n] = 1)

    const max = Math.max(...Object.values(obj))
    return Object.values(obj).reduce((acc, cur) => {
        if (cur == max) {
            acc += cur
        } return acc
    }, 0)
};

======================================================================================================================================================
Day 25: Is Object Empty
Example 1:

Input: obj = {"x": 5, "y": 42}
Output: false
Explanation: The object has 2 key-value pairs so it is not empty.
Example 2:

Input: obj = {}
Output: true
Explanation: The object doesn't have any key-value pairs so it is empty.


/*var isEmpty = function(obj) {
    for (let key in obj)
        return false;
    return true;
};

If array/object is not empty, interpreter will enter the for-in loop and hence first return statement (false) will be executed.
If array/object is empty, interpreter won't enter for-in loop and hence second return statement (true) will be executed.
*/

var isEmpty = function(obj) {
  if (Array.isArray(obj)) {
    return obj.length === 0;
  } else if (typeof obj === 'object') {
    return Object.keys(obj).length === 0;
  }
  return false; 
};

======================================================================================================================================================
Day 26: Longest Valid Parentheses

Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".

function longestValidParentheses(s) {
    let stack = [-1]; // Initialize stack with -1 to handle edge case where the first character is ')'
    let maxLength = 0;

    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i); // Push the index of an open parenthesis onto the stack
        } else {
            stack.pop(); // Pop the top element from the stack

            if (stack.length === 0) {
                stack.push(i); // If stack becomes empty, push the current index onto the stack
            } else {
                // Calculate the length of the valid substring and update maxLength
                maxLength = Math.max(maxLength, i - stack[stack.length - 1]);
            }
        }
    }

    return maxLength; // Return the length of the longest valid parenthesis substring
}

======================================================================================================================================================
Day 27: Best Time to Buy and Sell Stock II

Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.

/*var maxProfit = function(prices) {
    // Initialize the max profit...
    let maximumProfit = 0;
    // Traverse all the element through loop...
    for (let i = 1; i < prices.length; i++) {
        // check if the price is greater at i...
        if (prices[i] > prices[i - 1])
            // Add the difference to profit and increse it...
            maximumProfit += prices[i] - prices[i - 1];
    }
    return maximumProfit;      // Return the meximum profit...
};

var maxProfit = function(prices) {
    if (prices === null || prices.length === 0) {
        return 0;
    }
    let profit = 0;
    let buyingPrice = prices[0];
    for (let i = 1; i < prices.length; i++) {
        if (prices[i] > buyingPrice) {
            profit += prices[i] - buyingPrice;
            buyingPrice = prices[i]; // Re-buying 
        } else if (prices[i] < buyingPrice) {
            buyingPrice = prices[i]; // Better price
        }
    }
    return profit;
    // T.C: O(N)
    // S.C: O(1)
};*/

var maxProfit = function(prices) {
    let diff = 0
    if (prices.length > 0) { // []
        prices.reduce((acc, next) => {
            if (next > acc) {
                diff += next - acc
            }
            return next
        })
    }
    return diff
};

======================================================================================================================================================
Day 28: Find the Duplicate Number
Input: nums = [1,3,4,2,2]
Output: 2

/*var findDuplicate = function(nums) {
    const seen = new Set();
    for (const num of nums) {
        if (seen.has(num)) {
            return num;
        }
        seen.add(num);
    }
    return -1;  // Just to satisfy the compiler, this should never be reached
}

var findDuplicate = function(nums) {
    var freq = {} 
    
    for (var n of nums) {
        if (n in freq) {return n}
        else {freq[n] = 1}
    }
};*/

function findDuplicate(arr){
    let char = {};
  for (let i = 0; i < arr.length; i++) {
    if (char[arr[i]]) {
      return arr[i];
    }
    char[arr[i]] = 1;
  }
  return null;
    }

// function findDuplicate(arr){
//     let newArr=arr.sort()
//     for(let i=0;i<arr.length ;i++){
//         if(newArr[i]==newArr[i+1]){
//             console.log( newArr[i])
//             return newArr[i]
//         }
//     }

// }

======================================================================================================================================================
Day 29: Join Two Arrays by ID
Input: 
arr1 = [
    {"id": 1, "x": 2, "y": 3},
    {"id": 2, "x": 3, "y": 6}
], 
arr2 = [
    {"id": 2, "x": 10, "y": 20},
    {"id": 3, "x": 0, "y": 0}
]
Output: 
[
    {"id": 1, "x": 2, "y": 3},
    {"id": 2, "x": 10, "y": 20},
    {"id": 3, "x": 0, "y": 0}
]
Explanation: The two objects with id=1 and id=3 are included in the result array without modifiction. The two objects with id=2 are merged together. The keys from arr2 override the values in arr1.


/*var join = function(arr1, arr2) {
    const result = {};

    // 1. initialization
    arr1.forEach(item => {
        result[item.id] = item;
    });
    // 2. joining
    arr2.forEach(item => {
        if (result[item.id]) {
            Object.keys(item).forEach(key => {
                result[item.id][key] = item[key];    
            });
        } else {
            result[item.id] = item;
        }
    });

    return Object.values(result);
};

var join = function(arr1, arr2) {
  const combinedArray = arr1.concat(arr2);
  const merged = {};

  combinedArray.forEach((obj) => {
    const id = obj.id;
    if (!merged[id]) {
      merged[id] = { ...obj };
    } else {
      merged[id] = { ...merged[id], ...obj };
    }
  });

  const joinedArray = Object.values(merged);
  joinedArray.sort((a, b) => a.id - b.id);

  return joinedArray;
}; 

var join = function(arr1, arr2) {
    let map={},arrs=[...arr1,...arr2].map((e)=> map[e.id]={...map[e.id],...e})
    return [...Object.values(map)]
};*/

var join = function(arr1, arr2) {
    let items = arr1.concat(arr2);

    let result = {};

    for(const obj of items) {
        if(!result[obj.id]) {
            result[obj.id] = obj;
            continue;
        } 

        result[obj.id] = {...result[obj.id], ...obj};
    }

    return Object.values(result);
};
======================================================================================================================================================
Day 30: Average Value of Even Numbers That Are Divisible by Three

Input: nums = [1,3,6,10,12,15]
Output: 9
Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.

/*var averageValue = function(nums) {
    let sum = 0;
    let count = 0;
    for (let n of nums) {
        if (n % 6 === 0) {
            sum += n;
            count++;
        }
    }
    return sum === 0 ? sum : Math.floor(sum / count);
};*/

var averageValue = function(nums) {
nums = nums.filter(a => a % 6 ===0)
return nums.length ? parseInt(nums.reduce((a,b) => a + b )/ nums.length) : 0
};
======================================================================================================================================================
Day 31: Richest Customer Wealth

Input: accounts = [[1,5],[7,3],[3,5]]
Output: 10
Explanation: 
1st customer has wealth = 6
2nd customer has wealth = 10 
3rd customer has wealth = 8
The 2nd customer is the richest with a wealth of 10.

/*var maximumWealth = function(accounts) {
        var res = 0;
        for(var i =0;i<accounts.length;i++){
            var temp = 0;
            for(var j = 0;j<accounts[i].length;j++){
                temp+=accounts[i][j];
            }
            res = Math.max(res,temp);
        }
        return res;
};
var maximumWealth = function(accounts) {
    return Math.max(...accounts.map(account => 
        account.reduce((accumulator, current) => accumulator + current, 0)
    ))
};*/

var maximumWealth = function (accounts) {
  let max = 0;

  accounts.forEach((element) => {
    let sum = element.reduce(function (x, y) {
      return x + y;
    }, 0);
    if (max < sum) max = sum;
  });

  return max;
};

======================================================================================================================================================
Feb-Day 1 - Shuffling string

Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.

/*var restoreString = function(s, idx) {
    const result = [];
    for(let i = 0; i < s.length; i++) {
        result[idx[i]] = s[i] //RESULT KE INDEX ME STRING KI VALUE DALNA HAIN
    }
    return result.join('');
};*/

var restoreString = function(s, indices) {
    let keys = {};
    indices.forEach((val, index) => keys[val] = s[index])
    
    return Object.values(keys).join('');
};

======================================================================================================================================================
Feb Day 2: Factorial Trailing Zeroes

Given an integer n, return the number of trailing zeroes in n!.

Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.

Example 1:

Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.

var trailingZeroes = function(n) {
    // Negative Number Edge Case...
    if (n < 0) return -1;
    // Initialize the output result i.e., the number of trailing zeroes...
	let output = 0;
    // Count number of 5s in prime factors of n!
	for (let idx = 5; n/idx >= 1; idx *= 5) { //n=3, id=5,25...
		output += Math.floor(n/idx);
	}
    // Return the number of trailing zeroes...
    return output;
};

======================================================================================================================================================
Feb Day 3: Is Subsequence

Input: s = "abc", t = "ahbgdc"
Output: true

var isSubsequence = function(s, t) {
        let i = 0, j = 0;
        while (i < s.length && j < t.length) {
            if (s[i] === t[j]) {
                i++;
            }
            j++;
        }
        return i === s.length;
    }

======================================================================================================================================================
Feb Day 4: First Unique Character in a String

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
Example 1:

Input: s = "leetcode"
Output: 0

/*var firstUniqChar = function(s) {
    for(i=0; i<s.length; i++)
        if(s.indexOf(s[i])===s.lastIndexOf(s[i])) return i
    return -1
};*/

var firstUniqChar = function(s) {
    let map = {}
    
    for (let char of s) {
        map[char] ? map[char]++ : map[char] = 1
    }
    
    for (let i = 0; i < s.length; i++) {
        if (map[s[i]] === 1) return i
    }
        
    return -1
};

======================================================================================================================================================
Feb Day 5: Find the Difference
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.

var findTheDifference = function(s, t) {
    return [...t].sort().find((char, i) => char !== [...s].sort()[i])
};
/*var findTheDifference = function(s, t) {
    var sChars = s.split('').sort();
    var tChars = t.split('').sort();
    var i;
    for(i = 0; i < sChars.length; i++) {
        if(tChars[i] !== sChars[i]) {
            return tChars[i];
        }
    }
    return tChars[i];
};*/
/*var findTheDifference = function (s, t) {
    for (let i = 0; i < s.length; i++) {
        t = t.replace(s[i], '')
    }
    return t;
};*/
/*var findTheDifference = function(s, t) {
    for (let letter of s)
        t = t.replace(letter, '');
    return t;
};*/

/*var findTheDifference = function(s, t) {
  var s = s.split("").sort((a,b)=> a-b).join(""); 
  var t = t.split("").sort((a,b)=> a-b).join("");
 // console.log(s,t)
  for(var i =0; i< t.length || s.length; i++){
      if(s[i] != t[i]){
          return t[i]
      }
  }
};
console.log(findTheDifference( "abcd", "abcde"))*/

======================================================================================================================================================
Feb Day 6: Group Anagram

Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

/*const groupAnagrams = strs => {
    const map = {};
    
    for (let str of strs) {
        const key = [...str].sort().join('');

        if (!map[key]) {
            map[key] = [];
        }

        map[key].push(str);
    }
    
    return Object.values(map);
};
//console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"]))

var groupAnagrams = function(strs) {
    let map = {}
    
    for (let str of strs) {
        let key = [...str].sort()
        map[key] = map[key] ? [...map[key], str] : [str]
    }
    
    return Object.values(map)
};

======================================================================================================================================================
Feb Day 7: Sort Characters By Frequency

Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.

/*var frequencySort = function(s) {
    const mp = new Map();
    for (const char of s) {
        mp.set(char, (mp.get(char) || 0) + 1);
    }
    
    const r = new Map([...mp.entries()].sort((a, b) => b[1] - a[1]));
    let ss = '';
    for (const [char, freq] of r.entries()) {
        ss += char.repeat(freq);
    }
    
    return ss;
};

var frequencySort = function(s) {
    
    const charMap = s.split('').reduce((acc, cur) => {acc[cur] = (acc[cur] || 0) + 1; return acc} , {})
    
    const sortedArr = Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]);
    
    return sortedArr.reduce((acc, cur) => acc + cur.repeat(charMap[cur]) ,'')
};*/

var frequencySort = function(s) {
   var map = {}
   for(var i = 0; i < s.length; i++) {
       map[s[i]] = map[s[i]] ? map[s[i]]+1 : 1
   }
    var keys = Object.keys(map).sort((a, b) => {return map[b] - map[a]})
    return "".concat(...keys.map((item) => {return item.repeat(map[item])}))
};

======================================================================================================================================================
Feb Day 8: Permutations II

Example 1:
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]

Example 2:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

var permuteUnique = function(nums) {
// Sort the input array in ascending order to group duplicate numbers together.
nums.sort((a, b) => a - b);

// Initialize an empty array to store the permutations.
let res = [];

// Define a recursive helper function to generate permutations.
let iterate = (arr, temp) => {
// Base case: if the current array contains only one element, add the temporary permutation to the result.
if (arr.length == 1) {
res.push([...temp, arr[0]]);
return;
}

 // Iterate through each element of the array.
 for (let i = 0; i < arr.length; i++) {
     // Skip duplicates to avoid generating duplicate permutations.
     if (arr[i] == arr[i - 1]) {
         continue;
     }

     // Recursively generate permutations by excluding the current element from the array.
     iterate(arr.filter((num, idx) => idx != i), [...temp, arr[i]]);
 }
};

// Start the recursive permutation generation with the initial array and an empty temporary permutation.
iterate(nums, []);

// Return the array of unique permutations.
return res;
};
------------------------------------

